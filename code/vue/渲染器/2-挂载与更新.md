#### 1.挂载子节点和元素的属性

为元素设置属性要比想象的复杂。
无论是通过 setArrribute 函数，还是直接操作 DOM 对象，都存在缺陷。

有必要先搞清楚两个重要的概念：
**HTML Attributes** 与 **DOM Properties**

#### 2.HTML Attributes 与 DOM Properties

要合理地设计虚拟节点的结构，理解**HTML Attributes** 与 **DOM Properties**之间的差异和关联非常重要，这也是正确的为元素设置属性的关键。

**核心原则**
**HTML Attributes**的作用是设置与之对应的**DOM Properties**的**初始值**。

例如

```html
<input id="my-input" type="text" value="foo" />

<div class="foo"></div>

<div aria-valuenow="75"></div>
```

id="my-input" 对应 el.id
type="text" 对应 el.type
value="foo" 对应 el.value

但 **DOM Properties** 与 **HTML Attributes** 的名字不总是一模一样的，甚至不是每个 DOM Property 都有对应的 **HTML Attribute**
**反之亦然**。
eg:
1.class="foo" 对应 el.className

```html
<div class="foo"></div>
```

2.el.textContent 设置元素的文本内容，但并没有与之对应的 HTML Attributes 完成同样的工作。

3.**aria-\***类的**HTML Attributes**就没有与之对应的 DOM Properties

一个**HTML Attributes** 可能关联多个 DOM properties：
实际上， HTML Attributes 的作用是设置与之对应的 DOM Properties 的**初始值**。
但仍可以通过 el.defaultValue 来访问初始值。如下：

```js
el.getAttribute("value"); // 'foo'
el.value; // 'bar'
el.defaultValue; // 'foo'
```

#### 3.正确设置元素属性

对于普通的 HTML 文件来说，当浏览器解析 HTML 代码后，会自动分析 HTML Attributes 并设置合适的 DOM Properties。但用户编写在 Vuejs 的单文件组件中的模板不会被浏览器解析，这意味着，原本浏览器要做的事情，现在需要框架来完成。

优先使用 DOM Properties 来修改属性，在不存在对应 DOM Property 的情况下，通过 setAttribute 来设置。
部分特殊的 DOM Attributes 属性也需要通过 setAttribute 来设置，例如只读属性 form

```html
<form id="form1"></form>
<input form="form1" />
```

属性的设置也应该被设计为**平台无关**，因此属性相关设置操作也应该被提取到渲染器选项中

```js
const renderer = createRenderer({
  createElement(tag) {},
  setElementText(el, text) {},
  insert(el, parent, anchor = null) {}
  patchProps(el, key, prevValue, nextValue) {
    if(shouldSetAsProps(el, key, nextValue)) {
      const type = typeof el[key]
      if(type === 'boolean' && nextValue === '') {
        el[key] = true
      } else {
        el[key] = nextValue
      }
    } else {
      el.setAttribute(key, nextValue)
    }
  }
})
```

#### 4.class 的处理

由于 Vue.js 对 class 属性做了增强，因此 class 属性处理存在特殊性。

在 Vue.js 中为元素设置类名有以下几种方式。

```html
1.字符串
<p class="foo bar"></p>

2.对象
<p :class="foo"></p>

3.数组
<p :class="['foo bar', { baz: true }]"></p>
```

这里需要封装一个 normalizeClass 函数将 class 属性值统一为字符串模式。

接下来如何设置 class 属性到元素？
三种方式的抉择：setAttribute，el.className，el.classList
哪种性能更好？
经测试是 el.className

```js
function patchProps(el, key, prevValue, nextValue) {
  if (key === "class") {
    el.className = nextValue || "";
  } else if (shouldSetAsProps(el, key, nextValue)) {
    const type = typeof el[key];
    if (type === "boolean" && nextValue === "") {
      el[key] = true;
    } else {
      el[key] = nextValue;
    }
  } else {
    el.setAttribute(key, nextValue);
  }
}
```

style 标签也做了增强，因此也需要特殊处理

#### 5.卸载操作

为什么不直接使用 innerHTML API 清空元素内容？

- 指令的执行逻辑
- 组件的生命周期

因此更好的卸载方式是，通过 真实元素 的卸载方法， 例如 parent.removeChild(el)

#### 6.区分 vnode 的类型

不同类型的 vnode 挂载和更新的方式会有区别 vnode.type
例如 string（html 标签） object（组件）...

#### 7.事件的处理

如何描述事件：约定以'on'开头的属性都是事件

如何将事件添加到 DOM 元素上：
在 patchProps 中调用 addEventListener 函数绑定事件即可

```js
patchProps(el, key, prevValue, nextValue) {
  // 匹配以 on 开头的属性，视为事件
  if(/^on/.test(key)) {
    const name = key.slice(2).toLowerCase()
    // 绑定事件
    el.addEventListener(name, nextValue)
  } else if(key === 'class') {
    // ....
  } else if(shouldSetAsProp(el, key, nextValue)) {
    // ...
  } else {
    // ...
  }
}
```

事件属性是如何更新的呢？

按照正常思路，可以先移除之前绑定的事件，再绑定新的事件。
但还有一种性能更有的方案，可以给元素绑定一个伪造的事件处理函数 invoker，
然后把真正的事件处理函数设置为 invoker.value 属性的值。
这样当更新事件的时候，我们就不再需要调用 removeEventListener 函数移除上一次绑定的事件，只需要更新 invoker.value 的值即可。

```js
patchProps(el, key, oldValue, newValue) {
  if(/^on/.test(key)) {
    let invoker = el._vei
    // 事件不存在
    if(!invoker) {
      invoker = el._vei = (e) => {
        invoker.value(e)
      }

      invoker.value = newValue

      el.addEventListener(name, invoker)
    } else {
      invoker.value = newValue
    }
  } else if(key === 'class') {
    // ...
  } else {
    // ...
  }
}
```

目前仍存在问题，同一时刻只能缓存一个事件处理函数，这意味着，如果一个元素绑定了多种事件，将会出现事件覆盖现象。

显而易见，el.\_vei 的结构应该被设计为一个对象，键是事件名称，值是对应的事件处理函数。

一个元素不仅会绑定多种事件，还有可能同一个事件绑定多个事件处理函数。

因此，vnode.props 对象中事件的数据结构要做调整，**el.\_vei**对象的 value 也应该被设计为数组。

```js
// vnode
const vnode = {
  type: "p",
  props: {
    onClick: [
      // 第一个事件处理函数
      () => {
        alert(1);
      },
      // 第二个事件处理函数
      () => {
        alert(2);
      },
    ],
    children: "text",
  },
};
```

#### 8.事件冒泡与更新时机问题

示例：

```js
const bol = ref(false)

effect(() => {
  // 创建vnode
  const vnode = {
    type: 'div',
    props: bol.value ? {
      onClick: () => {
        alert('父元素clicked')
      }
    },
    children: [
      {
        type: 'p',
        props: {
          onClick: () => {
            bol.value = value
          }
        },
        children: 'text'
      }
    ]
  }

  renderer.render(vnode, document.querySelector("#app"))
})

```

触发 p 元素点击事件 -> p 元素事件处理函数执行 -> 触发副作用函数重新执行 -> 渲染器 -> 为 div 元素绑定事件 -> 事件冒泡到 div -> 触发 div 事件处理函数执行

这个现象可能会令人迷惑，不符合正常思维，vue 是如何解决的这个问题？

思路是，**屏蔽所有绑定时间晚于事件触发时间的事件处理函数**。
具体做法比较简单，在伪造的 invoker 事件处理函数上添加一个属性用来存储事件注册时间。

这里时间比较，事件绑定存储的时间是 performance.now()获得的高精时间。
事件对象上存在 timeStamp 属性，表示事件触发时间，这里不同浏览器实现不一，有的可能是高精时间，有的不是，因此这里做了兼容性处理。

#### 9.更新子节点

为方便更新时处理子节点，需要规范化子节点类型

三种情况

- 没有子节点
- 文本子节点
- 一组子节点

```js
const vnode = {
  type: "div",
  children: null,
};

const vnode = {
  type: "div",
  children: "text",
};

const vnode = {
  type: "div",
  children: [
    {
      type: "p",
      children: "text",
    },
    "text",
  ],
};
```

patchElement:

```js
function patchElement(n1, n2) {
  const el = (n2.el = n1.el);
  const oldProps = n1.props;
  const newProps = n2.props;

  // 第一步：更新props
  for (const key in newProps) {
    if (newProps[key] !== oldProps[key]) {
      patchProps(el, key, oldProps[key], newProps[key]);
    }
  }

  for (const key in oldProps) {
    if (!(key in newProps)) {
      patchProps(el, key, oldProps[key], null);
    }
  }

  // 第二步：更新子元素
  patchChildren(n1, n2, el);
}
```

patchChildren:

```js
function patchChildren(n1, n2, container) {
  // 子节点的类型只有三种可能：文本，数组
  if (typeof n2.children === "string") {
    if (Array.isArray(n1.children)) {
      n1.children.forEach((child) => unmount(child));
    }
    setElementText(container, n2.children);
  } else if (Array.isArray(n2.children)) {
    // 新节点子元素为数组

    if (Array.isArray(n1.children)) {
      // 旧节点子元素也为数组
      // 这里涉及核心的 Diff 算法
    } else {
      // 旧节点子元素为 字符串/null,无所谓清空内容就行
      // 然后逐个挂载新元素
      setElementText(container, "");
      n2.children.forEach((child) => patch(null, child, container));
    }
  } else {
    // 新子节点不存在
    if (Array.isArray(n1.children)) {
      // 旧子节点是数组，逐一卸载旧子节点
      n1.children.forEach((child) => unmount(child));
    } else if (typeof n1.children === "string") {
      // 旧子节点是字符串，清空即可
      setElementText(container, "");
    }
  }
}
```

#### 10.文本节点和注释节点

```js
const Text = Symbol();

const newVnode = {
  type: Text,
  children: "文本内容",
};

const Comment = Symbol();

const newVnode = {
  type: Comment,
  children: "注释内容",
};
```

patch:

```js
function patch(n1, n2, container) {
  const { type } = n2;

  if (type === "string") {
    if (!n1) {
      mountElement(n2, container);
    } else {
      patchElement(n1, n2, container);
    }
  } else if (type === Text) {
    if (!n1) {
      // 创建文本子节点
      const el = (n2.el = createText(n2.children));
      insert(el, container);
    } else {
      const el = (n2.el = n1.el);
      if (n1.children !== n2.children) {
        setText(n2.children, container);
      }
    }
  }
}

function createRenderer({
  createText: (text) => {
    return document.createTextNode(text)
  },
  setText: (text, el) => {
    el.nodeValue = text
  }
}) {

  // render,
  // patch,
  // createApp
  //...
return {
  render
}
}
```

createText, setText 也需要调用特定平台的 api，因此也应该作为参数配置传入 createRenderer

注释节点跟文本节点类似，不过是注释节点需要使用 documnet.createComment 函数来创建

#### 11.Fragment

Fragment 元素本身并不会渲染任何内容，所以只需要处理它的子节点即可。
因此特性 unmount 函数需要对 Fragment 作出特殊处理。即卸载时逐一卸载子元素即可。

```js
function unmount(vnode) {
  if (vnode.type === Fragment) {
    vnode.children.forEach((child) => unmount(child));
    return;
  }
  const parent = vnode.el.parentNode;
  if (parent) {
    parent.removeChild(vnode.el);
  }
}
```
