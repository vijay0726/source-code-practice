####

渲染器是框架性能的核心，渲染器的实现直接影响框架的性能。

渲染器的代码量非常庞大，需要合理的架构设计来保证可维护性，不过实现思路并不复杂。

#### 渲染器与响应系统的结合

顾名思义，渲染器是用来执行渲染任务的。
在浏览器平台上，用它来渲染器中的真实 DOM 元素。
渲染器不仅能渲染真实 DOM 元素，它也是框架跨平台能力的关键。
因此，渲染器的设计需要考虑好可自定义的能力。

#### 渲染器的基本概念

renderer

渲染器的作用是把虚拟 DOM 渲染为特定平台上的真实元素。

渲染器把虚拟 DOM 节点渲染为真实 DOM 节点的过程叫做**挂载**，**mount**

渲染器（renderer）不可与渲染（render）划等号，后者是动词，表示的渲染这个动作，而渲染器的概念更加宽泛。
以下代码可见一斑：

```js
const createRenderer = () => {
  // 渲染函数
  const render = (vnode, container) => {}

  // SSR 激活（水合）函数
  cosnt hydrate = (vnode, container) => {}
  return {
    render,
    hydrate
  }
}
```

甚至 创建应用的 createApp 函数也是渲染器的一部分。

渲染器除了要执行挂载动作外，还要执行更新动作。

例如

```js
const renderer = createRenderer();

// 首次渲染
renderer.render(oldVnode, document.querySelector("#app"));
// 第二次渲染
renderer.render(newVnode, document.querySelector("#app"));
```

我们一般将更新的过程叫做“打补丁”，patch
不过不必纠结“挂载”和“打补丁”，挂载动作本身也可以看做一种特殊的打补丁，它的特殊之处在于旧的 vnode 是不存在的。

```js
function createRenderer = () => {
  function render(vnode, container) {
    if(vnode) {
      // 新 vnode 存在，将其与旧的 vnode 一起传递给 patch 函数，进行打补丁
      patch(container._vnode, vnode, container)
    } else {
      if(container._vnode) {
        // 旧 vnode 不存在，且新 vnode 不存在，说明是卸载 unmount 操作
        container.innerHTML = ''
      }
    }

    container._vnode = vnode
  }


  return {
    render
  }
}


// 首次渲染
renderer.render(oldVnode, document.querySelector('#app'))
// 第二次渲染
renderer.render(newVnode, document.querySelector('#app'))
// 第三次渲染
renderer.render(null, document.querySelector('#app'))
```

#### 自定义渲染器

要实现通用的渲染器，能够将虚拟 DOM 渲染为指定平台的真实元素，就需要将特定的 API 抽离。

例如 document.createElement, el.textContent, appendChild 等

怎么做？

可以将这些操作 DOM 的 API 作为配置项，该配置项可以作为 createRenderer 函数的参数

```js
const renderer = createRenderer({
  // 用于创建元素
  createElement(tag) {
    return documnet.createElement(tag)
  },

  // 用于设置元素的文本节点
  setElement(el, text) {
    el.textContent(text)
  }

  // 用于给指定的 parent 下添加指定元素
  insert(el, parent, anchor) {
    parent.insertBefore(el, anchor)
  }

})
```
