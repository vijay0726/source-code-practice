#### Proxy和Reflect的使用

访问器属性的this问题需要使用Reflect来解决。
#### 合理的触发响应
eg:
在值发生变化时才触发更新

#### 浅响应与深响应
浅响应：只监听第一层数据的变化
深响应：递归的处理深层对象属性

#### 只读和浅只读
在 设置数据的访问器属性中拦截操作

#### 代理数组

1.访问length属性，需要给length属性建立唯一KEY，来收集依赖
track(target, ITERATE_KEY)

2.遍历数组

3.数组的查找方法

4.隐式修改数组长度的原型方法

#### 代理Set和Map

1.如何建立响应式

2.避免污染原始数据

我们把 将响应式数据设置到原始数据上的操作称为数据污染。

3.处理forEach
在不做处理的情况下，即使调用的是Set,Map实例的代理对象的forEach，在callback中拿到的value,key,target也是原始数据，因此需要重写forEach方法，将参数处理为响应式数据。

4.迭代器方法（entries, Symbol.iterator）
跟forEach类似，迭代器中的数据也需要处理为响应式数据。

对于Set类型，ADD || DELETE 数据，需要触发 ITERATE_KEY 相关的依赖。

对于Map类型来说，forEach, entries, values 等方法都关心value的变化，因此需要在 SET 操作时，触发 ITERATE_KEY关联的依赖

然而keys 方法并不关心value，只关心key的变化，因此在SET操作时并不需要触发 与此相关的操作，只有在ADD || DELETE操作时触发与 迭代keys相关联的依赖更新。

可以通过设置 MAP_KEY_ITERATE_KEY 来实现与 ITERATE_KEY 依赖收集的分离。

5.keys和values方法

由于map.keys() 方法关心的只是key的变化，不关心value的变化，
Map类型在调用for of 遍历 keys() 时，不需要触发更新 ITERATE_KEY 相关的依赖