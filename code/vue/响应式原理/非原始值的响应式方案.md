#### Proxy和Reflect的使用
所谓代理，指的是对一个对象**基本语义**的代理。

访问器属性的this问题需要使用Reflect来解决。

在ECMA规范中，有两种对象**常规对象** 和 **异质对象**

代理对象的本质，就是查阅规范并找到可拦截的基本操作的方法。有一些操作并不是基本操作，而是复合操作，这需要查阅规范了解这些复合操作依赖了哪些基本操作，从而通过基本操作的拦截方法间接地处理复合操作。
#### 合理的触发响应
eg:
在值发生变化时才触发更新；
对NAN的处理；
访问原型链上的属性导致副作用函数重新执行两次...

#### 浅响应与深响应
浅响应：只监听第一层数据的变化
深响应：递归的处理深层对象属性

#### 只读和浅只读
在 设置数据的访问器属性中拦截操作

#### 代理数组

数组时一个**异质对象**，因为数组对象内部部署的[[DefineOwnProperty]]不同于常规对象。

1.访问length属性，需要给length属性建立唯一KEY，来收集依赖
track(target, ITERATE_KEY)

2.遍历数组

3.数组的查找方法
includes, indexOf, lastIndexOf 等

这里需要注意的点是，用户既可能使用代理对象进行查找，也可能使用原始对象进行查找，因此需要重写这些方法。

原理很简单，可以先去代理对象中查找，如果找不到，再去原始数组中查找。

4.隐式修改数组长度的原型方法
push, pop, shift, unshift, splice等，调用这些方法会间接地读取和设置数组的length属性，因此在不同的副作用函数内对同一个数组执行上述方法，会导致多个副作用函数之间循环调用，最终导致调用栈溢出。
为了解决这个问题，可以使用一个标记变量**shouldTrack**来代表是否允许进行追踪，然后重写这些方法。
目的是当这些方法间接读取length属性时，将shouldTrack先设置为false，即禁止追踪。这样就可以断开length属性与副作用函数之间的响应联系，从而避免循环调用导致的调用栈溢出。


#### 代理Set和Map

1.如何建立响应式
Set,Map,WeekSet,WeekMap

集合类型数据不同于普通对象，它有特定的数据操作方法。

例如，size属性是一个访问器属性，当通过代理对象访问size属性时，由于代理对象本身并没有部署[[SetData]]这样的内部槽，所以会发生错误。

2.避免污染原始数据

我们把 不小心将响应式数据设置到原始数据上的操作称为数据污染。

解决数据污染的思路是，在调用target.set()函数之前对值进行检查即可：
只要发现即将设置的值是响应式数据，那么就听过**“raw”**属性获取原始数据，再把原始数据设置到target上。

3.处理forEach
在不做处理的情况下，即使调用的是Set,Map实例的代理对象的forEach，在callback中拿到的value,key,target也是原始数据，因此需要重写forEach方法，将参数处理为响应式数据。

4.迭代器方法（entries, Symbol.iterator）
跟forEach类似，迭代器中的数据也需要处理为响应式数据。

对于Set类型，ADD || DELETE 数据，需要触发 ITERATE_KEY 相关的依赖。

对于Map类型来说，forEach, entries, values 等方法都关心value的变化，因此需要在 SET 操作时，触发 ITERATE_KEY关联的依赖

然而keys 方法并不关心value，只关心key的变化，因此在SET操作时并不需要触发 与此相关的操作，只有在ADD || DELETE操作时触发与 迭代keys相关联的依赖更新。

可以通过设置 MAP_KEY_ITERATE_KEY 来实现与 ITERATE_KEY 依赖收集的分离。

5.keys和values方法

由于map.keys() 方法关心的只是key的变化，不关心value的变化，
Map类型在调用for of 遍历 keys() 时，不需要触发更新 ITERATE_KEY 相关的依赖