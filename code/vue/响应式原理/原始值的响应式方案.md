#### 

const refVal1 = ref(1)
const refVal1 = reactive({value: 1})

vue3 中涉及到自动脱ref的能力，因此有必要能够区分ref和reactive对象。

ref的作用不仅仅是实现原始值的响应式方案，它还用来解决响应丢失问题。

如何区分？

```js
function ref(val) {
  const wrapper = {
    value: val
  }

  // 使用Object.defineProperty 在 wrapper 对象上定义一个不可枚举的属性__v_isRef，并且值为 true
  Object.defineProperty(wrapper, '__v_isRef', {
    value: true
  })

  return reactive(wrapper)
}
```

#### 响应丢失

```js
const obj1 = reactive({foo: 1, bar: 2})
const obj2 = {...obj1}

effect(() => {
  console.log(obj2.foo)
})

obj1.foo = 3 // 不会触发副作用函数
```
解决思路：
```js
const obj2 = {
  get foo() {
    return obj1.foo
  },

  get bar() {
    return obj1.bar
  }
}

// 封装为函数
const toRef = (obj, key) => {
  const wrapper = {
    get value() {
      return obj[key]
    }
  }

  return wrapper
}

// 批量
const toRefs = (obj) => {
  const ret = {}

  for(const key in obj) {
    ret[key] = toRef(obj, key)
  }

  return ret
}
```

这样实现的toRef，创建的ref对象是只读的，因为wrapper上只设置了getter 访问器属性。
因此还应该加上setter：
```js
function toRef(obj, key) {
  const wrapper = {
    get value() {
      return obj[key]
    },

    set value(val) {
      obj[key] = val
    }
  }

  Object.defineProperty(wrapper, '__v_isRef', {
    value: true
  })

  return wrapper
}
```
#### 自动脱ref

toRefs函数解决了响应式丢失的问题，但也带来了新的问题。
由于toRefs会把响应式数据的第一层属性值转换为ref，因此必须通过value属性访问

```js
const obj = reactive({foo: 1})

const newObj = {...toRefs(obj)}

newObj.foo.value // 1
```
在模版中肯定不希望通过value属性来访问数据，增加了用户心智负担

针对这个问题，可以通过代理来实现自动脱ref
这个时候就需要能够判断一个数据是否为ref对象，也就是需要使用到__v_isRef 属性

```js
function proxyRefs(target) {
  return newProxy(target, {
    get(target, key, receiver) {
      const value = Reflect.get(target, key, receiver)

      return value.__v_isRef ? value.value : value
    },

    set(target, key, newVal, receiver) {
      const value = target[key]

      if(value.__v_isRef) {
        value.value = newVal
        return true
      }

      return Reflect.set(target, key, newVal, receiver)
    }
  })
}
```
自动脱ref的应用场景不仅仅是 **处理setup 返回的数据**，
实际上在reactive函数中也存在。

```js
const count = ref(0)

const obj = reactive({ count })
```



